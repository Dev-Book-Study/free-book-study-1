# B-Tree와 LSM Tree: RDBMS와 NoSQL 데이터베이스의 성능 비교

최근 "**데이터 중심 애플리케이션 개발**"을 읽으면서 RDBMS와 NoSQL의 차이를 설명하는 내용을 알게 되었습니다. 이 내용을 기반으로 두 가지 데이터베이스를 비교해보려고 합니다.   

## B-Tree와 LSM Tree의 기본 구조

MySQL InnoDB와 같은 RDBMS는 B-Tree 기반의 저장소 엔진을 사용하는 반면, MongoDB와 같은 NoSQL 데이터베이스는 주로 로그 기반(LSM Tree) 구조를 활용합니다. 이 두 방식은 근본적인 설계 철학부터 성능 특성까지 다양한 차이점을 가지고 있습니다.

### B-Tree 구조 (RDBMS)
B-Tree는 RDBMS에서 널리 사용되는 색인 구조입니다. B-Tree는 데이터를 균형 잡힌 트리 형태로 구성하며, 고정 크기의 페이지 단위로 디스크에 저장합니다. 트리의 각 노드(페이지)는 키와 그에 해당하는 하위 페이지 참조를 포함하고 있습니다. 일반적으로 데이터를 삽입, 삭제, 수정할 때는 해당 페이지의 내용을 **직접 덮어쓰는 방식**을 사용합니다.  

이러한 **균형 트리 구조**를 통해 어떤 **키**에 대해서도 `O(log n)` 시간 복잡도로 검색이 가능하며, 대부분의 데이터베이스에서 B-Tree의 깊이는 3-4 수준에 불과해 매우 빠른 접근 시간을 제공합니다.

```
       [루트 페이지]
       /    |    \
[페이지1] [페이지2] [페이지3]
  / \      / \      / \
... ...  ... ...  ... ...
```

### LSM Tree 구조 (NoSQL)
LSM Tree(로그 구조화 병합 트리)는 로그 기반의 저장 구조를 사용합니다.  

데이터를 수정할 때마다 디스크에 **순차적으로 추가**하는 방식을 사용하기 때문에, 기존 데이터를 덮어쓰지 않습니다. 새로운 데이터는 먼저 메모리 내의 멤테이블(MemTable)에 버퍼링되고, 멤테이블이 일정 크기에 도달하면 디스크의 SS테이블(Sorted String Table)로 기록됩니다.  

시간이 지남에 따라 여러 SS테이블이 생성되며, 백그라운드에서 주기적으로 이들을 **병합**하고 **압축**하는 **컴팩션** 프로세스가 실행됩니다. 이러한 순차적 쓰기 방식은 B-Tree에서 정해진 위치의 데이터를 덮어쓰는 방법과 달리 파일에 맨 뒤에 추가만 하는 방식이므로 별도의 특정 위치에 대한 확인 같은 부수적인 처리가 없고 디스크의 물리적 특성에 최적화되어 있으므로 일반적으로 쓰기 작업에서 뛰어난 성능을 보입니다.  

```
[MemTable(메모리)]  →  [SS테이블1(디스크)]  →  [SS테이블2(디스크)]  →  ...
                          ↓                        ↓
                     [컴팩션 프로세스]          [컴팩션 프로세스]
                          ↓                        ↓
                     [병합된 SS테이블]       [병합된 SS테이블]
```

## 3. 읽기/쓰기 성능 특성 비교

### 읽기 성능

**B-Tree (RDBMS)의 읽기 성능**  

B-Tree 구조에서는 인덱스를 통해 데이터에 직접 접근할 수 있습니다.   

균형 잡힌 트리 구조를 통해 어떤 키에 대해서도 `O(log n)` 시간 내에 검색이 가능하며, 대부분의 경우 단 몇 번의 디스크 I/O만으로 원하는 레코드에 도달할 수 있습니다. 특히 기본 키를 이용한 검색은 매우 효율적이며, 색인된 열을 기준으로 한 범위 쿼리(B+ Tree)도 높은 성능을 보입니다.  

또한 B-Tree는 데이터가 정렬된 상태로 유지되므로 정렬된 결과가 필요한 쿼리에서도 유리합니다. 인덱스가 메모리에 캐시되어 있다면 더욱 빠른 접근이 가능합니다.

---

**LSM Tree (NoSQL)의 읽기 성능**  

LSM Tree 구조에서는 특정 키를 검색할 때 여러 SS테이블을 차례로 확인해야 할 수 있습니다.  

키를 찾기 위해 먼저 메모리의 멤테이블을 확인하고, 없다면 가장 최근에 생성된 SS테이블부터 차례대로 확인합니다. 이 과정에서 여러 번의 디스크 접근이 필요할 수 있어 B-Tree보다 읽기 성능이 떨어질 수 있습니다.  

그러나 **블룸 필터**와 같은 최적화 기법을 사용하여 특정 키가 존재하지 않는 SS테이블을 효율적으로 건너뛸 수 있습니다. 또한 컴팩션 작업이 진행 중일 때는 읽기 성능이 일시적으로 저하될 수 있습니다.   

한편, 순차적 읽기나 스캔 작업에서는 데이터의 연속적 배치로 인해 우수한 성능을 보일 수 있습니다.

### 쓰기 성능

**B-Tree (RDBMS)의 쓰기 성능**  

B-Tree 구조에서는 데이터를 수정할 때 해당 페이지를 직접 덮어써야 합니다. 이는 **무작위 I/O** 패턴을 유발하여 특히 하드 디스크 드라이브(HDD)에서 성능 저하의 원인이 됩니다. 또한 B-Tree의 균형을 유지하기 위해 데이터 삽입 시 **페이지 분할**이 발생할 수 있으며, 이는 **추가적인 디스크 I/O**를 필요로 합니다.  

또한 인덱스가 여러 개 있는 경우, 데이터 수정 시 **모든 관련 인덱스를 업데이트**해야 하므로 쓰기 오버헤드가 증가합니다.  

데이터 변경의 안전한 복구를 위해 WAL(Write-Ahead Log)을 유지해야 하므로, 하나의 트랜잭션에 대해 여러 번의 디스크 쓰기가 필요할 수 있습니다. 이러한 특성으로 인해 B-Tree는 쓰기 작업이 많은 워크로드에서는 성능 병목이 될 수 있습니다.  

---

**LSM Tree (NoSQL)의 쓰기 성능**  

LSM Tree 구조는 쓰기 작업에 최적화되어 있습니다.  

데이터 변경 시 디스크에 **순차적으로 추가**하므로, 특히 HDD에서 효율적입니다. 새로운 데이터는 먼저 메모리의 멤테이블에 버퍼링되므로 디스크 I/O 횟수를 크게 줄일 수 있습니다. 대량의 데이터를 삽입할 때도 멤테이블이 가득 차기 전까지는 디스크에 기록할 필요가 없어 빠른 속도로 처리됩니다.  

기존 데이터를 덮어쓰지 않고 새 버전을 추가하는 방식이므로 페이지 분할과 같은 구조 재조정이 필요 없습니다. 물론 컴팩션 과정이 필요하지만, 이는 백그라운드에서 처리되므로 전면적인 쓰기 성능에는 영향이 적습니다.   

이러한 특성으로 인해 LSM Tree는 특히 쓰기가 많은 워크로드에서 우수한 성능을 보입니다.


## MySQL InnoDB의 버퍼풀 최적화

일반적으로 순차적 쓰기를 활용하는 NoSQL이 쓰기 작업에서는 더 나은 성능을 보이지만, 실제 운영 환경에서는 다른 결과를 만들 수 있다고 책에서 언급하고 있는데요, 제가 생각하는 대표적인 예시는 MySQL **InnoDB**입니다.   

MySQL InnoDB의 버퍼풀(Buffer Pool)은 B-Tree의 쓰기 성능 약점을 극복하는 데 도움을 줍니다. 

### 버퍼풀의 핵심 기능

**변경 버퍼(Change Buffer)**  

변경 버퍼는 보조 인덱스에 대한 변경 사항을 **즉시 디스크에 반영하지 않고 메모리에 버퍼링**하는 기능입니다.   

데이터가 변경될 때마다 모든 관련 인덱스를 즉시 업데이트하는 대신, 변경 내용을 메모리에 기록해두고 나중에 배치 처리 방식으로 디스크에 적용합니다. 이를 통해 **무작위 I/O 작업이 크게 줄어들고**, 특히 다수의 보조 인덱스가 있는 테이블에서 삽입, 수정, 삭제 작업의 성능이 **대폭 향상**됩니다.  

변경 버퍼는 시스템 리소스가 여유 있을 때 또는 관련 페이지가 다른 이유로 메모리에 로드될 때 디스크에 플러시됩니다.

---

**더티 페이지 관리**  

InnoDB는 메모리에서 변경된 페이지(더티 페이지)를 효율적으로 관리하는 메커니즘을 가지고 있습니다.  

버퍼풀 내의 더티 페이지는 플러시 리스트(flush list)를 통해 추적되며, 이를 통해 변경된 순서대로 디스크에 기록할 수 있습니다. InnoDB는 더티 페이지를 디스크에 쓸 때 인접한 페이지들을 함께 그룹화하여 처리함으로써 랜덤 I/O를 최소화합니다. 또한 적응형 플러시 알고리즘을 사용하여 시스템 부하에 따라 플러시 속도를 조절하고, 체크포인트 처리를 최적화하여 복구 시간을 단축합니다.

---

**적응형 해시 인덱스**  

적응형 해시 인덱스는 InnoDB가 자주 접근하는 데이터 패턴을 자동으로 감지하여 메모리에 해시 인덱스를 생성하는 기능입니다.   

이 기능은 반복적으로 동일한 조건의 쿼리가 실행될 때 특히 유용합니다. 적응형 해시 인덱스를 통해 B-Tree 탐색 과정을 완전히 우회하고 O(1) 시간 복잡도로 데이터에 직접 접근할 수 있게 됩니다. 이는 특히 읽기 작업이 많은 워크로드에서 성능을 크게 향상시킵니다. 하지만 고부하 상황에서는 해시 인덱스 유지 비용이 증가할 수 있으므로, MySQL은 이 기능을 선택적으로 활성화하거나 비활성화할 수 있는 옵션을 제공합니다.  

(쓰기 작업과 관련된 내용은 아니지만 중요하다고 생각해서 추가했습니다.)  

---

**이중 쓰기 버퍼**  

이중 쓰기 버퍼(Doublewrite Buffer)는 데이터 무결성을 보장하면서도 쓰기 성능을 향상시키는 매커니즘입니다.   

페이지 쓰기 도중 시스템 충돌이 발생할 경우 "부분 페이지 쓰기" 문제가 발생할 수 있는데, 이중 쓰기 버퍼는 이 문제를 해결합니다. 더티 페이지를 데이터 파일에 직접 쓰기 전에 먼저 연속된 이중 쓰기 버퍼 영역에 기록하고, 이후 원래 위치에 분산하여 기록합니다. 이를 통해 시스템 충돌 시에도 완전한 페이지를 복구할 수 있으며, 연속된 영역에 쓰기 때문에 I/O 효율성도 향상됩니다.   

특히 SSD에서는 이 기능의 오버헤드가 크게 줄어들어 효과적입니다.

---

**리두 로그 최적화**  

InnoDB는 **리두 로그**(Redo Log)를 통해 트랜잭션의 지속성과 복구 가능성을 보장합니다.   

리두 로그는 순차적 쓰기 방식을 사용하므로 디스크 I/O 성능이 최적화됩니다. 또한 그룹 커밋(Group Commit) 기능을 통해 여러 트랜잭션의 커밋을 배치 처리함으로써 I/O 오버헤드를 줄입니다. InnoDB는 리두 로그 버퍼 크기, 로그 파일 크기, 로그 쓰기 빈도 등을 조정할 수 있는 다양한 구성 옵션을 제공하여 워크로드에 맞게 최적화할 수 있습니다.  

리두 로그 최적화는 특히 쓰기 작업이 많은 워크로드에서 B-Tree의 성능을 크게 향상시킬 수 있습니다.  

## 실제 환경에서의 데이터베이스 선택

이론적인 차이점만으로는 실제 환경에서의 성능을 정확히 예측하기 어렵습니다. 다음과 같은 요소들이 성능에 큰 영향을 미칩니다.

### 고려해야 할 요소

**워크로드 특성**  

워크로드의 읽기/쓰기 비율은 데이터베이스 선택에 중요한 요소입니다.   

읽기가 대부분인 워크로드(일반적인 웹 서비스)에서는 B-Tree 기반 RDBMS가 유리할 수 있습니다. 반면, 쓰기가 많은 워크로드(예: 로깅, 이벤트 수집)에서는 LSM Tree 기반 NoSQL이 더 효율적일 수 있습니다.   

쿼리 패턴도 중요한데, **복잡한 조인**이나 **트랜잭션**이 필요한 경우 RDBMS가 적합하며, 단순한 **키-값 조회**가 주된 작업이라면 NoSQL이 더 간단하고 효율적일 수 있습니다.   

**데이터 크기**와 **성장 속도**도 고려해야 하는데, 대용량 데이터에서는 LSM Tree의 우수한 압축률과 확장성이 장점이 될 수 있습니다.  

---

**하드웨어 환경**  

하드웨어 환경은 데이터베이스 성능에 직접적인 영향을 미칩니다.  

HDD를 사용하는 경우, 순차적 I/O에 최적화된 LSM Tree가 무작위 I/O가 많은 B-Tree보다 유리합니다. SSD에서는 무작위 I/O의 패널티가 줄어들어 B-Tree의 단점이 완화됩니다.  

**사용 가능한 메모리** 양도 중요한 요소입니다. 대용량 버퍼풀이 가능한 환경에서는 B-Tree의 읽기/쓰기 성능이 크게 향상되며, LSM Tree의 컴팩션 오버헤드가 상대적으로 더 부담스러울 수 있습니다.  

**CPU 자원**도 고려해야 하는데, LSM Tree의 백그라운드 컴팩션 작업은 추가적인 CPU 자원을 소모하므로, CPU 제한이 있는 환경에서는 이점이 감소할 수 있습니다.

---

**애플리케이션 요구사항**  

애플리케이션의 **데이터 일관성**, **트랜잭션**, **가용성** 요구사항도 데이터베이스 선택에 중요한 요소입니다.  

ACID 트랜잭션이 중요한 금융, 전자상거래 등의 애플리케이션에서는 RDBMS를 선호하는 경향이 있습니다. 반면, 일시적인 데이터 불일치를 허용할 수 있는 소셜 미디어, 로깅 등의 애플리케이션에서는 NoSQL의 유연성과 확장성이 장점이 될 수 있습니다.  

**스키마 변경 빈도**도 고려사항입니다. 스키마가 자주 변경되는 환경에서는 스키마리스 또는 스키마 유연성이 높은 NoSQL이 유리할 수 있습니다. 지리적 분산이나 고가용성 요구사항이 있는 경우, 분산 설계가 기본적으로 포함된 일부 NoSQL 솔루션이 적합할 수 있습니다.


## 실제 벤치마크 테스트의 중요성  

이론적인 성능 특성은 중요한 지침이 되지만, 실제 운영 환경에서 다른 다른 결과가 나올 수 있기 때문에 최종 결정은 실제 애플리케이션 데이터와 워크로드를 사용한 벤치마크 테스트를 통해 이루어져야 한다고 언급하고 있습니다.  

---

**실제 데이터 크기와 분포 반영**  

벤치마크 테스트는 반드시 **실제 애플리케이션에서 사용할 데이터의 크기와 분포**를 반영해야 합니다.   

합성 데이터나 균일하게 분포된 테스트 데이터는 실제 환경에서의 성능을 정확히 예측하지 못할 수 있습니다. 실제 데이터는 종종 불균형하게 분포되어 있으며, 이런 데이터 편향(skew)은 데이터베이스 성능에 큰 영향을 미칩니다. 특히 인덱스 효율성, 캐시 히트율, 쿼리 실행 계획 등에 영향을 줍니다.  
가능하다면 프로덕션 데이터의 익명화된 사본이나 통계적으로 유사한 데이터셋을 사용하여 테스트하는 것이 좋습니다.

---

**실제 쿼리 패턴 테스트**  

애플리케이션의 **실제 쿼리 패턴**을 사용한 벤치마크가 중요합니다.   

단순한 CRUD 작업만으로는 복잡한 애플리케이션의 성능을 예측하기 어렵습니다. 실제 애플리케이션에서 자주 사용되는 쿼리, 특히 **성능 병목이 될 가능성이 있는 복잡한 쿼리들을 포함**시켜야 합니다.  

실제 워크로드의 **읽기/쓰기 비율**, **동시 접속 수준**, **쿼리 복잡성** 등을 반영한 **테스트 시나리오를 구성**해야 합니다. 또한 피크 시간대의 부하를 시뮬레이션하여 최악의 상황에서도 성능 요구사항을 충족하는지 확인해야 합니다.

---

**확장성 테스트**  

데이터베이스는 시간이 지남에 따라 데이터 볼륨이 증가하므로, 확장성 테스트가 필요할 수 있습니다. 현재 데이터 크기뿐만 아니라 예상되는 미래 데이터 크기에서도 테스트를 수행하면 좋습니다.   

데이터 증가에 따른 쿼리 성능 변화, 인덱스 효율성 변화, 저장 공간 요구사항 등을 측정해야 합니다. 또한 데이터 증가에 따른 백업, 복구, 유지보수 작업의 성능도 고려해야 합니다. 하드웨어 리소스(CPU, 메모리, 디스크 I/O, 네트워크 대역폭) 사용률을 모니터링하여 어떤 리소스가 병목이 되는지 파악하고, 스케일업 또는 스케일아웃 전략을 계획해야 합니다.

---

**장기 실행 테스트**  

데이터베이스 성능은 시간이 지남에 따라 변화할 수 있으므로, 장기 실행 테스트가 필요할 수 있습니다.  

LSM Tree 기반 데이터베이스는 시간이 지남에 따라 컴팩션 오버헤드가 누적될 수 있고, B-Tree 기반 데이터베이스는 메모리 단편화나 인덱스 불균형 문제가 발생할 수 있습니다. 따라서 단기 성능뿐만 아니라 며칠 또는 몇 주에 걸친 장기 실행 테스트를 통해 성능 저하 패턴을 분석해야 합니다.  

백그라운드 작업(컴팩션, 통계 업데이트, 백업 등)이 전체 시스템 성능에 미치는 영향도 평가해야 합니다. 또한 장애 상황(노드 장애, 디스크 오류 등) 후 복구 성능과 데이터 일관성도 테스트해야 합니다.

## 결론

MySQL InnoDB와 MongoDB 같은 NoSQL 데이터베이스는 기본적으로 다른 저장소 엔진 설계로 인해 서로 다른 성능 특성을 가집니다. B-Tree 기반의 InnoDB는 전통적으로 읽기 성능이 우수하고, LSM Tree 기반의 NoSQL은 쓰기 성능이 뛰어난 것으로 알려져 있습니다.

그러나 InnoDB의 버퍼풀 최적화와 같은 기술을 통해 실제 환경에서는 사용 측면에서 별 차이가 없는 경우가 많기 때문에, 결국 최적의 데이터베이스 선택은 이론적인 특성보다 실제 애플리케이션의 요구사항, 워크로드 특성, 그리고 실제 환경에서의 벤치마크 테스트 결과에 기반해야 합니다. 필요하다면 현재 사용중인 기술, 다른 기여자들의 러닝 커브 등도 함께 고려될 수 있습니다.  

데이터베이스 선택은 단순한 "RDBMS vs NoSQL" 논쟁이 아니라, 특정 사용 사례에 맞는 적절한 도구를 선택하는 과정이라는 점을 기억해야 하며, 때하이브리드 접근 방식이나 다중 데이터베이스 전략이 최적의 솔루션일 수 있습니다.  
